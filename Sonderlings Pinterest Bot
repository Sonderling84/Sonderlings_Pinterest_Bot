import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from dotenv import load_dotenv
from datetime import datetime

# Lade Umgebungsvariablen
load_dotenv()

# Logging einrichten
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class TelegramMediaBot:
    def __init__(self):
        self.token = os.getenv("BOT_TOKEN")
        self.allowed_users = [int(x) for x in os.getenv("ALLOWED_USERS", "").split(",") if x]
        self.max_file_size = int(os.getenv("MAX_FILE_SIZE", "50"))
        
        # Zielkan√§le
        self.channels = {
            "photos": os.getenv("PHOTO_CHANNEL", "@sonderling_fotos"),
            "videos": os.getenv("VIDEO_CHANNEL", "@sonderling_videos"),
            "documents": os.getenv("DOC_CHANNEL", "@sonderling_docs"),
            "general": os.getenv("GENERAL_CHANNEL", "@sonderling_all")
        }
    
    def is_user_allowed(self, user_id):
        """Pr√ºfe Berechtigung"""
        return not self.allowed_users or user_id in self.allowed_users
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Start Command"""
        user_id = update.effective_user.id
        
        if not self.is_user_allowed(user_id):
            await update.message.reply_text("‚ùå Du bist nicht berechtigt, diesen Bot zu verwenden.")
            return
        
        keyboard = [
            [InlineKeyboardButton("üì∏ Foto posten", callback_data="help_photo")],
            [InlineKeyboardButton("üé• Video posten", callback_data="help_video")],
            [InlineKeyboardButton("üìÑ Dokument posten", callback_data="help_document")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "ü§ñ **Sonderling's Media Bot**\n\n"
            "Sende mir Medien und ich poste sie automatisch in die konfigurierten Kan√§le!\n\n"
            "‚úÖ Unterst√ºtzte Formate:\n"
            "üì∏ Bilder (JPG, PNG, GIF, WebP)\n"
            "üé• Videos (MP4, AVI, MOV, MKV)\n"
            "üìÑ Dokumente (PDF, ZIP, TXT)\n\n"
            f"üìä Max. Dateigr√∂√üe: {self.max_file_size}MB",
            parse_mode="Markdown",
            reply_markup=reply_markup
        )
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle Callback Queries"""
        query = update.callback_query
        await query.answer()
        
        if query.data == "help_photo":
            await query.edit_message_text("üì∏ **Foto-Hilfe**\n\nSende einfach ein Bild und ich poste es automatisch in die Foto-Kan√§le!", parse_mode="Markdown")
        elif query.data == "help_video":
            await query.edit_message_text("üé• **Video-Hilfe**\n\nSende ein Video und ich poste es automatisch in die Video-Kan√§le!", parse_mode="Markdown")
        elif query.data == "help_document":
            await query.edit_message_text("üìÑ **Dokument-Hilfe**\n\nSende eine Datei und ich poste sie automatisch in die Dokument-Kan√§le!", parse_mode="Markdown")
    
    async def handle_photo(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle Photos"""
        if not self.is_user_allowed(update.effective_user.id):
            return
        
        photo = update.message.photo[-1]
        
        # Gr√∂√üe pr√ºfen
        if photo.file_size > self.max_file_size * 1024 * 1024:
            await update.message.reply_text(
                f"‚ùå Bild zu gro√ü! Max: {self.max_file_size}MB"
            )
            return
        
        # In Kan√§le posten
        posted_channels = []
        caption = f"üì∏ Von: {update.effective_user.first_name}\nüìÖ {datetime.now().strftime('%d.%m.%Y %H:%M')}"
        
        for channel_type, channel_id in self.channels.items():
            if channel_type in ["photos", "general"]:
                try:
                    await context.bot.send_photo(
                        chat_id=channel_id,
                        photo=photo.file_id,
                        caption=caption
                    )
                    posted_channels.append(channel_id)
                except Exception as e:
                    logger.error(f"Fehler beim Posten in {channel_id}: {e}")
        
        await update.message.reply_text(
            f"‚úÖ Foto gepostet in {len(posted_channels)} Kan√§le!"
        )
    
    async def handle_video(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle Videos"""
        if not self.is_user_allowed(update.effective_user.id):
            return
        
        video = update.message.video
        
        if video.file_size > self.max_file_size * 1024 * 1024:
            await update.message.reply_text(
                f"‚ùå Video zu gro√ü! Max: {self.max_file_size}MB"
            )
            return
        
        posted_channels = []
        caption = f"üé• Von: {update.effective_user.first_name}\nüìÖ {datetime.now().strftime('%d.%m.%Y %H:%M')}"
        
        for channel_type, channel_id in self.channels.items():
            if channel_type in ["videos", "general"]:
                try:
                    await context.bot.send_video(
                        chat_id=channel_id,
                        video=video.file_id,
                        caption=caption
                    )
                    posted_channels.append(channel_id)
                except Exception as e:
                    logger.error(f"Fehler beim Posten in {channel_id}: {e}")
        
        await update.message.reply_text(
            f"‚úÖ Video gepostet in {len(posted_channels)} Kan√§le!"
        )
    
    async def handle_document(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle Documents"""
        if not self.is_user_allowed(update.effective_user.id):
            return
        
        document = update.message.document
        
        if document.file_size > self.max_file_size * 1024 * 1024:
            await update.message.reply_text(
                f"‚ùå Datei zu gro√ü! Max: {self.max_file_size}MB"
            )
            return
        
        posted_channels = []
        caption = f"üìÑ {document.file_name}\nüë§ Von: {update.effective_user.first_name}\nüìÖ {datetime.now().strftime('%d.%m.%Y %H:%M')}"
        
        for channel_type, channel_id in self.channels.items():
            if channel_type in ["documents", "general"]:
                try:
                    await context.bot.send_document(
                        chat_id=channel_id,
                        document=document.file_id,
                        caption=caption
                    )
                    posted_channels.append(channel_id)
                except Exception as e:
                    logger.error(f"Fehler beim Posten in {channel_id}: {e}")
        
        await update.message.reply_text(
            f"‚úÖ Dokument gepostet in {len(posted_channels)} Kan√§le!"
        )

def main():
    """Hauptfunktion"""
    bot = TelegramMediaBot()
    
    if not bot.token:
        logger.error("BOT_TOKEN nicht gefunden!")
        return
    
    # Application erstellen
    application = Application.builder().token(bot.token).build()
    
    # Handler hinzuf√ºgen
    application.add_handler(CommandHandler("start", bot.start))
    application.add_handler(CallbackQueryHandler(bot.handle_callback))
    application.add_handler(MessageHandler(filters.PHOTO, bot.handle_photo))
    application.add_handler(MessageHandler(filters.VIDEO, bot.handle_video))
    application.add_handler(MessageHandler(filters.DOCUMENT, bot.handle_document))
    
    # Bot starten
    logger.info("ü§ñ Bot startet auf Railway...")
    
    # Railway verwendet einen PORT
    port = int(os.environ.get("PORT", 8080))
    application.run_webhook(
        listen="0.0.0.0",
        port=port,
        webhook_url=f"https://your-app-name.railway.app/"
    )

if __name__ == "__main__":
    main()
